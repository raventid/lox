#+TITLE: Readme

This is my notes for loxi interpeter. Simple interpreter written in Java. (Please, see repo readme for more details).

** Grammar rules
Expressions:
|------------+--------------------------------------------------------------------------------------|
| Name       | Expr                                                                                 |
|------------+--------------------------------------------------------------------------------------|
| expression | assignment ;                                                                         |
|------------+--------------------------------------------------------------------------------------|
| assignment | IDENTIFIER "=" assignment or equality ;                                              |
|------------+--------------------------------------------------------------------------------------|
| equality   | comparison ( ( "!=" or "==" ) comparison )* ;                                        |
|------------+--------------------------------------------------------------------------------------|
| comparison | term ( ( ">" or ">=" or "<" or "<=" ) term )* ;                                      |
|------------+--------------------------------------------------------------------------------------|
| term       | factor ( ( "-" or "+" ) factor )* ;                                                  |
|------------+--------------------------------------------------------------------------------------|
| factor     | unary ( ( "/" or "*" ) unary )* ;                                                    |
|------------+--------------------------------------------------------------------------------------|
| unary      | ("!" or "-") unary or primary ;                                                      |
|------------+--------------------------------------------------------------------------------------|
| primary    | NUMBER or STRING or "true" or "false" or "nil" or "(" expression ")" or IDENTIFIER ; |
|------------+--------------------------------------------------------------------------------------|

Statements:
|-------------+------------------------------------------|
| program     | statement* EOF ;                         |
|-------------+------------------------------------------|
| block       | "{" declaration "}" ;                    |
|-------------+------------------------------------------|
| declaration | varDecl or statement ;                   |
|-------------+------------------------------------------|
| statement   | exprStmt or printStmt or block ;         |
|-------------+------------------------------------------|
| exprStmt    | expression ";" ;                         |
|-------------+------------------------------------------|
| varDecl     | "var" IDENTIFIER ("=" expression)? ";" ; |
|-------------+------------------------------------------|
| printStmt   | "print" expression ";" ;                 |
|-------------+------------------------------------------|

** Glossary
*** Compilation stages
**** Front end
***** Lexer/Scanner/Lexical analysis
Reads an input, creates ~tokens~
***** Parser
Panicking - state the parser enters after seeing malformed input
Synchronizing parser - run recovery after error happens
Parser error is a syntax error
***** AST/Trees/Syntax tree
***** Static analysis and resolution
****** Binding and resolution
For each identifier we find where this name is defined and wire them together
****** Type checking
****** Datastructures used
To store some information related to static analyzis we can use multiple places:
******* Attributes
Attach the info to the correspondent the AST node
******* Symbol table
KV store
******* Tree transformation (rearranging nodes, transposing to the other DS)
**** Middle end
***** Intermediate representation
Helps to solve ~multiple languages x multiple targets~ problem.
Compile every langauge to IR.
Compile IR to target.
***** Optimisation
**** Back end
***** Code generation (code gen)
***** Runtime
Garbage collection, keeping track of the type (if we have "instance of" construction)
*** Operators
infix - between operands
postfix - after an operand
prefix - before an operand

unary - one operand
binary - two operands
ternary - three operands

Can operator have more than 3 operands? We probably can consider pattern matching to be an operator, in this case it accepts dynamic amount of operands
APL language also provides some operators that can consume more than 3 operands.

*** Declaring vs defining
Some languages like C make a distinction between defining a function and declaring a function. Declaration only exist to ensure type checking so it does not require a function body.

*** Function argument vs function parameter
Argument - actual value passed to the function. Function call contains an argument list. (also ~actual parameter~)
Parameter - variable that holds the value of the argument inside the body of the function. Function declaration has a parameter list. (~formal parameters or formals~)


** Compiler vs interpreter
*** Compilation
Translation from one language to the other
*** Interpretation
Execution of the code in a given form (AST, bytecode or other)

Most of the languages are compilers, only small amount are pure interpreters (probably only tree walking interpreter could be considered a pure interpreter)


** General notes about interpreters and some terminology
TODO: add more commments about grammar what does top/down in grammar means.

When we are talking about parser there are two domains. Grammar and Precedence.
Their understand of top/down is reversed.
#+ATTR_HTML: width="400px"
#+ATTR_ORG: :width 400
[[./misc/grammar_and_precedence.png]]


l-value vs r-value
#+begin_src javascript
var a = 10;
a = 20; // a is called l-value, 20 is called r-value (l-value is an assignment place, r-value is expr to eval)
#+end_src

TODO: How exactly does lack of explicit declaration complicates scope analyses. (i.e. in Ruby we use implicit decls and it works)

Why use ~var~ declaration and not an implicit declaration like ~a = 10~? It complicates the work with embedded scopes and with growing popularity of functional constructions, lambdas and deep scopes it is easier to work with explicit decls.

** Loxi
*** REPL
I use makefiles to control ~build and execute~ procedure, please use ~make repl~ to run interpreter.
